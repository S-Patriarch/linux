// 
// (c) 2024 S-Patriarch
//
// пример работы с std::promise в мире асинхронного выполнения кода
// std::promise является второй сущностью поставки значения для future
//
// класс std::future представляет собой обертку, над каким-либо значением или
// объектом, вычисление или получение которого происходи отложено т.е. future 
// предоставляет доступ к некоторому разделяемому состоянию, которое состоит 
// из 2-х частей: данные (здесь лежит значение) и флаг готовности
// future является получателем значения и не может самостоятельно выставлять
// его; роль future пассивна
//
#include <future>
#include <thread>
#include <limits>
#include <cstdio>
////////////////////////////////////////////////////////////////////////////////
int main ()
   // создается поток, который отсчитывает числа с конца и уведомляет
   // ожидающую сторону, что число, переданное в качестве аргумента, найдено
   // объект promise обернут в shared_ptr
   // это необходимо для копирования promise в новый поток
   // хотя можно было ее и переместить туда, но, к сожалению lambda не
   // содержит синтаксиса для "перемещающего захвата", а другими методами
   // делать это не хочется
   // в этом коде set_value без параметров
   // это специальная версия set_value для promise параметризованной типом void
   // для остальных типов этот метод принимает один аргумент
   // 
   // из кода видно, что promise предоставляет больше свободы, чем packaged_task,
   // которая ограничена выставлением значения только из возвращаемого значения
   // функции, а следовательно, только по ее завершению
   // promise по факту, является самым гибким поставщиком значения для future
   // 
   // std::promise следует использовать в местах, где необходим полный
   // контроль над местом выставления значения
{
   auto pr = std::make_shared<std::promise<void>>();
   std::future<void> w = pr->get_future();
   auto call = [pr](std::size_t value) {
      std::size_t i = std::numeric_limits<std::size_t>::max();
      while (i--) {
      	if (i==value) pr->set_value();
      }
   };
   std::thread t(call,std::numeric_limits<std::size_t>::max()-500);
   t.detach();
   w.get();
   return 0;
}
